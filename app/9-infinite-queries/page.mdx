import { Callout } from "nextra/components"

# 9. Infinity queries

## 1

–†–µ–∞–ª–∏–∑—É–µ–º –Ω–∞ —Å—Ç—Ä–∞–Ω–∏—Ü–µ —Å —Ç—Ä–µ–∫–∞–º–∏

<Callout type={"info"} emoji={"üîó"}>
  [Infinite Queries](https://redux-toolkit.js.org/rtk-query/usage/infinite-queries)
</Callout>

`infiniteQuery` –ø–æ–¥—Ö–æ–¥–∏—Ç –¥–ª—è:

- –ë–µ—Å–∫–æ–Ω–µ—á–Ω–æ–π –ø—Ä–æ–∫—Ä—É—Ç–∫–∏ (infinite scroll)
- –ö–Ω–æ–ø–∫–∏ "–ó–∞–≥—Ä—É–∑–∏—Ç—å –µ—â–µ"
- –õ–µ–Ω—Ç—ã –Ω–æ–≤–æ—Å—Ç–µ–π/–ø–æ—Å—Ç–æ–≤
- –ö–æ–≥–¥–∞ –Ω—É–∂–Ω–æ –ø–æ–∫–∞–∑–∞—Ç—å –≤—Å–µ –¥–∞–Ω–Ω—ã–µ –≤ –æ–¥–Ω–æ–º —Å–ø–∏—Å–∫–µ

## 2

- `features/tracks/api/tracksApi.ts`

```ts filename="features/tracks/api/tracksApi.ts"
export const tracksApi = baseApi.injectEndpoints({
  endpoints: (build) => ({
    fetchTracks: build.infiniteQuery<FetchTracksResponse, FetchTracksArgs, number>({
      infiniteQueryOptions: {
        initialPageParam: 1,
        getNextPageParam: (_lastPage, _allPages, lastPageParam) => {
          return lastPageParam + 1
        },
      },
      query: ({ queryArg, pageParam }) => ({ url: "playlists/tracks", params: queryArg }),
    }),
  }),
})

export const { useFetchTracksInfiniteQuery } = tracksApi
```

- `features/tracks/api/tracksApi.types.ts`

```ts filename="features/tracks/api/tracksApi.types.ts"
import type { CurrentUserReaction } from "@/common/enums"
import type { Images, User } from "@/common/types"

export type FetchTracksResponse = {
  data: TrackData[]
  included: TracksIncluded[]
  meta: TracksMeta
}

export type TrackData = {
  id: string
  type: "tracks"
  attributes: TrackAttributes
  relationships: TrackRelationships
}

export type TracksIncluded = {
  id: string
  type: "artists"
  attributes: {
    name: string
  }
}

export type TracksMeta = {
  nextCursor: string | null
  page: number
  pageSize: number
  totalCount: number
  pagesCount: number
}

export type TrackAttributes = {
  title: string
  addedAt: string
  attachments: TrackAttachment[]
  images: Images
  currentUserReaction: CurrentUserReaction
  user: User
  isPublished: boolean
  publishedAt: string
}

export type TrackRelationships = {
  artists: {
    data: {
      id: string
      type: string
    }
  }
}

export type TrackAttachment = {
  id: string
  addedAt: string
  updatedAt: string
  version: number
  url: string
  contentType: string
  originalName: string
  fileSize: number
}

// Arguments
export type FetchTracksArgs = {
  pageNumber?: number
  pageSize?: number
  search?: string
  sortBy?: "publishedAt" | "likesCount"
  sortDirection?: "asc" | "desc"
  tagsIds?: string[]
  artistsIds?: string[]
  userId?: string
  includeDrafts?: boolean
  paginationType?: "offset" | "cursor"
  cursor?: string
}
```

## ü§î

<Callout>
  –†–∞—Å—Å–º–æ—Ç—Ä–µ—Ç—å –º–µ—Ç–æ–¥—ã:
  - [flat](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/flat) –∏
  - [flatMap](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/flatMap)

</Callout>

## ‚ùå

```tsx
export const PlaylistsPage = () => {
  const [playlistId, setPlaylistId] = useState<string | null>(null)

  const { register, handleSubmit, reset } = useForm<UpdatePlaylistArgs>()

  const [search, setSearch] = useState("")
  const debounceSearch = useDebounceValue(search)

  const { data, isLoading, fetchNextPage, isFetchingNextPage, hasNextPage } = useFetchInfinitePlaylistsInfiniteQuery({
    search: debounceSearch,
  })

  /*...*/

  return (
    <div className={s.container}>
      <h1>Playlists page</h1>
      <CreatePlaylistForm />
      <input
        type="search"
        placeholder={"Search playlist by title"}
        onChange={(e) => setSearch(e.currentTarget.value)}
      />

      {/* Load More  */}
      <div>
        <button onClick={fetchNextPage} disabled={!hasNextPage || isLoading}>
          {isFetchingNextPage ? "Loading more..." : hasNextPage ? "Load More" : "Nothing more to load"}
        </button>
      </div>

      <div className={s.items}>
        {!data?.pages[0].data.length && !isLoading && <h2>Playlists not found</h2>}
        {data?.pages
          ?.flatMap((page) => page.data)
          .map((playlist) => {
            const isEditing = playlistId === playlist.id

            return (
              <div className={s.item} key={playlist.id}>
                {isEditing ? (
                  <EditPlaylistForm
                    playlistId={playlistId}
                    handleSubmit={handleSubmit}
                    register={register}
                    editPlaylist={editPlaylistHandler}
                    setPlaylistId={setPlaylistId}
                  />
                ) : (
                  <PlaylistItem
                    playlist={playlist}
                    deletePlaylist={deletePlaylistHandler}
                    editPlaylist={editPlaylistHandler}
                  />
                )}
              </div>
            )
          })}
      </div>
    </div>
  )
}
```
