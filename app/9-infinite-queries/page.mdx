import { Callout } from "nextra/components"

# 9. Infinity queries

## 1

–†–µ–∞–ª–∏–∑—É–µ–º –±–µ—Å–∫–æ–Ω–µ—á–Ω—ã–π —Å–∫—Ä–æ–ª–ª –Ω–∞ —Å—Ç—Ä–∞–Ω–∏—Ü–µ —Å —Ç—Ä–µ–∫–∞–º–∏

<Callout type={"info"} emoji={"üîó"}>
  [Infinite Queries](https://redux-toolkit.js.org/rtk-query/usage/infinite-queries)
</Callout>

`infiniteQuery` –ø–æ–¥—Ö–æ–¥–∏—Ç –¥–ª—è:

- –ë–µ—Å–∫–æ–Ω–µ—á–Ω–æ–π –ø—Ä–æ–∫—Ä—É—Ç–∫–∏ (infinite scroll)
- –ö–Ω–æ–ø–∫–∏ "–ó–∞–≥—Ä—É–∑–∏—Ç—å –µ—â–µ"
- –õ–µ–Ω—Ç—ã –Ω–æ–≤–æ—Å—Ç–µ–π/–ø–æ—Å—Ç–æ–≤
- –ö–æ–≥–¥–∞ –Ω—É–∂–Ω–æ –ø–æ–∫–∞–∑–∞—Ç—å –≤—Å–µ –¥–∞–Ω–Ω—ã–µ –≤ –æ–¥–Ω–æ–º —Å–ø–∏—Å–∫–µ

## 2

- `features/tracks/api/tracksApi.ts`

```ts filename="features/tracks/api/tracksApi.ts"
export const tracksApi = baseApi.injectEndpoints({
  endpoints: (build) => ({
    fetchTracks: build.infiniteQuery<FetchTracksResponse, FetchTracksArgs, number>({
      infiniteQueryOptions: {
        initialPageParam: 1,
        getNextPageParam: (_lastPage, _allPages, lastPageParam) => {
          return lastPageParam + 1
        },
      },
      query: ({ queryArg, pageParam }) => ({ url: "playlists/tracks", params: queryArg }),
    }),
  }),
})

export const { useFetchTracksInfiniteQuery } = tracksApi
```

- `features/tracks/api/tracksApi.types.ts`

```ts filename="features/tracks/api/tracksApi.types.ts"
import type { CurrentUserReaction } from "@/common/enums"
import type { Images, User } from "@/common/types"

export type FetchTracksResponse = {
  data: TrackData[]
  included: TracksIncluded[]
  meta: TracksMeta
}

export type TrackData = {
  id: string
  type: "tracks"
  attributes: TrackAttributes
  relationships: TrackRelationships
}

export type TracksIncluded = {
  id: string
  type: "artists"
  attributes: {
    name: string
  }
}

export type TracksMeta = {
  nextCursor: string | null
  page: number
  pageSize: number
  totalCount: number
  pagesCount: number
}

export type TrackAttributes = {
  title: string
  addedAt: string
  attachments: TrackAttachment[]
  images: Images
  currentUserReaction: CurrentUserReaction
  user: User
  isPublished: boolean
  publishedAt: string
}

export type TrackRelationships = {
  artists: {
    data: {
      id: string
      type: string
    }
  }
}

export type TrackAttachment = {
  id: string
  addedAt: string
  updatedAt: string
  version: number
  url: string
  contentType: string
  originalName: string
  fileSize: number
}

// Arguments
export type FetchTracksArgs = {
  pageNumber?: number
  pageSize?: number
  search?: string
  sortBy?: "publishedAt" | "likesCount"
  sortDirection?: "asc" | "desc"
  tagsIds?: string[]
  artistsIds?: string[]
  userId?: string
  includeDrafts?: boolean
  paginationType?: "offset" | "cursor"
  cursor?: string
}
```

## 3

–í—ã–∑–æ–≤–µ–º —Ö—É–∫ `useFetchTracksInfiniteQuery` –∏ –ø–æ—Å–º–æ—Ç—Ä–∏ –Ω–∞ –ø–æ–ª—É—á–µ–Ω–Ω—ã–π —Ä–µ–∑—É–ª—å—Ç–∞—Ç

```tsx filename="TracksPage.tsx"
export const TracksPage = () => {
  const { data } = useFetchTracksInfiniteQuery({ paginationType: "cursor", pageSize: 5 })

  console.log(data)

  return (
    <div>
      <h1>Tracks page</h1>
    </div>
  )
}
```

–û–±—Ä–∞—Ç–∏—Ç–µ –≤–Ω–∏–º–∞–Ω–∏–µ, —á—Ç–æ —Ö—É–∫ –≤–µ—Ä–Ω—É–ª –Ω–∞–º —Å—Ç—Ä—É–∫—Ç—É—Ä—É `{pages: DataType[], pageParams: PageParam[]},`
–∫–æ—Ç–æ—Ä–∞—è —Å–æ–¥–µ—Ä–∂–∏—Ç –≤—Å–µ –ø–æ–ª—É—á–µ–Ω–Ω—ã–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã —Å—Ç—Ä–∞–Ω–∏—Ü –∏ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—â–∏–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã —Å—Ç—Ä–∞–Ω–∏—Ü, –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–Ω—ã–µ –¥–ª—è –∏—Ö –∑–∞–≥—Ä—É–∑–∫–∏.

–≠—Ç–∞ —Å—Ç—Ä—É–∫—Ç—É—Ä–∞ –æ–±–µ—Å–ø–µ—á–∏–≤–∞–µ—Ç –≥–∏–±–∫–æ—Å—Ç—å –≤ –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏–∏ –¥–∞–Ω–Ω—ã—Ö –≤ –≤–∞—à–µ–º –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–µ (–ø–æ–∫–∞–∑—ã–≤–∞—Ç—å –æ—Ç–¥–µ–ª—å–Ω—ã–µ —Å—Ç—Ä–∞–Ω–∏—Ü—ã –∏–ª–∏
–æ–±—ä–µ–¥–∏–Ω—è—Ç—å –≤ –µ–¥–∏–Ω—ã–π —Å–ø–∏—Å–æ–∫), –ø–æ–∑–≤–æ–ª—è–µ—Ç –æ–≥—Ä–∞–Ω–∏—á–∏–≤–∞—Ç—å –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Å—Ç—Ä–∞–Ω–∏—Ü, —Ö—Ä–∞–Ω—è—â–∏—Ö—Å—è –≤ –∫–µ—à–µ, –∞ —Ç–∞–∫–∂–µ –¥–∞—ë—Ç –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å
–¥–∏–Ω–∞–º–∏—á–µ—Å–∫–∏ –æ–ø—Ä–µ–¥–µ–ª—è—Ç—å —Å–ª–µ–¥—É—é—â—É—é –∏–ª–∏ –ø—Ä–µ–¥—ã–¥—É—â—É—é —Å—Ç—Ä–∞–Ω–∏—Ü—É –¥–ª—è –∑–∞–≥—Ä—É–∑–∫–∏ ‚Äî –Ω–∞ –æ—Å–Ω–æ–≤–µ —Å–∞–º–∏—Ö –¥–∞–Ω–Ω—ã—Ö –∏–ª–∏ –∏—Ö –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤.

![infinite query](https://production-it-incubator.s3.eu-central-1.amazonaws.com/file-manager/Image/c6dd0f71-4977-48a6-adc0-035e123683f5_infinite-query.png)

–û—Ç—Ä–∏—Å—É–µ–º –¥–∞–Ω–Ω—ã–µ

<Callout>
  –ß—Ç–æ–±—ã —É–º–µ–Ω—å—à–∏—Ç—å –≤–ª–æ–∂–µ–Ω–Ω–æ—Å—Ç—å –≤–æ—Å–ø–æ–ª—å–∑—É–µ–º—Å—è `flat` –∏–ª–∏ `flatMap`
  - [flat](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/flat)
  - [flatMap](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/flatMap)

</Callout>

- `TracksPage.tsx`

```tsx filename="TracksPage.tsx"
import { useFetchTracksInfiniteQuery } from "../../api/tracksApi.ts"
import s from "./TracksPage.module.css"

export const TracksPage = () => {
  const { data } = useFetchTracksInfiniteQuery({ paginationType: "cursor", pageSize: 5 })

  const pages = data?.pages.map((page) => page.data).flat() || []
  // const pages = data?.pages.flatMap((page) => page.data) || []

  return (
    <div>
      <h1>Tracks page</h1>
      <div className={s.list}>
        {pages.map((track) => {
          const { title, user, attachments } = track.attributes

          return (
            <div key={track.id} className={s.item}>
              <div>
                <p>Title: {title}</p>
                <p>Name: {user.name}</p>
              </div>
              {attachments.length ? <audio controls src={attachments[0].url} /> : "no file"}
            </div>
          )
        })}
      </div>
    </div>
  )
}
```

- `TracksPage.module.css`

```css filename="TracksPage.module.css"
.list {
  display: flex;
  flex-direction: column;
  gap: 20px;
}

.item {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 16px;
  border: 1px solid #ddd;
  border-radius: 8px;
}
```

**–†–µ–∑—É–ª—å—Ç–∞—Ç:** –æ—Ç—Ä–∏—Å–æ–≤–∞–ª–∏ –ø–µ—Ä–≤—É—é —Å—Ç—Ä–∞–Ω–∏—Ü—É üöÄ

## 4

## ‚ùå

```tsx
export const PlaylistsPage = () => {
  const [playlistId, setPlaylistId] = useState<string | null>(null)

  const { register, handleSubmit, reset } = useForm<UpdatePlaylistArgs>()

  const [search, setSearch] = useState("")
  const debounceSearch = useDebounceValue(search)

  const { data, isLoading, fetchNextPage, isFetchingNextPage, hasNextPage } = useFetchInfinitePlaylistsInfiniteQuery({
    search: debounceSearch,
  })

  /*...*/

  return (
    <div className={s.container}>
      <h1>Playlists page</h1>
      <CreatePlaylistForm />
      <input
        type="search"
        placeholder={"Search playlist by title"}
        onChange={(e) => setSearch(e.currentTarget.value)}
      />

      {/* Load More  */}
      <div>
        <button onClick={fetchNextPage} disabled={!hasNextPage || isLoading}>
          {isFetchingNextPage ? "Loading more..." : hasNextPage ? "Load More" : "Nothing more to load"}
        </button>
      </div>

      <div className={s.items}>
        {!data?.pages[0].data.length && !isLoading && <h2>Playlists not found</h2>}
        {data?.pages
          ?.flatMap((page) => page.data)
          .map((playlist) => {
            const isEditing = playlistId === playlist.id

            return (
              <div className={s.item} key={playlist.id}>
                {isEditing ? (
                  <EditPlaylistForm
                    playlistId={playlistId}
                    handleSubmit={handleSubmit}
                    register={register}
                    editPlaylist={editPlaylistHandler}
                    setPlaylistId={setPlaylistId}
                  />
                ) : (
                  <PlaylistItem
                    playlist={playlist}
                    deletePlaylist={deletePlaylistHandler}
                    editPlaylist={editPlaylistHandler}
                  />
                )}
              </div>
            )
          })}
      </div>
    </div>
  )
}
```
