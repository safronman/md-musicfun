import { Callout } from "nextra/components"

# 9. Infinity queries

–†–µ–∞–ª–∏–∑—É–µ–º –±–µ—Å–∫–æ–Ω–µ—á–Ω—ã–π —Å–∫—Ä–æ–ª–ª –Ω–∞ —Å—Ç—Ä–∞–Ω–∏—Ü–µ —Å —Ç—Ä–µ–∫–∞–º–∏

<Callout type={"info"} emoji={"üîó"}>
  [Infinite Queries](https://redux-toolkit.js.org/rtk-query/usage/infinite-queries)
</Callout>

`infiniteQuery` –ø–æ–¥—Ö–æ–¥–∏—Ç –¥–ª—è:

- –ë–µ—Å–∫–æ–Ω–µ—á–Ω–æ–π –ø—Ä–æ–∫—Ä—É—Ç–∫–∏ (infinite scroll)
- –ö–Ω–æ–ø–∫–∏ "–ó–∞–≥—Ä—É–∑–∏—Ç—å –µ—â–µ"
- –õ–µ–Ω—Ç—ã –Ω–æ–≤–æ—Å—Ç–µ–π/–ø–æ—Å—Ç–æ–≤
- –ö–æ–≥–¥–∞ –Ω—É–∂–Ω–æ –ø–æ–∫–∞–∑–∞—Ç—å –≤—Å–µ –¥–∞–Ω–Ω—ã–µ –≤ –æ–¥–Ω–æ–º —Å–ø–∏—Å–∫–µ

## cursor paginate

### api

- `features/tracks/api/tracksApi.ts`

```ts filename="features/tracks/api/tracksApi.ts"
export const tracksApi = baseApi.injectEndpoints({
  endpoints: (build) => ({
    fetchTracks: build.infiniteQuery<FetchTracksResponse, void, string | undefined>({
      infiniteQueryOptions: {
        initialPageParam: undefined,
        getNextPageParam: (lastPage) => {
          return lastPage.meta.nextCursor || undefined
        },
      },
      query: ({ pageParam }) => {
        return {
          url: "playlists/tracks",
          params: { cursor: pageParam, pageSize: 5, paginationType: "cursor" },
        }
      },
    }),
  }),
})
export const { useFetchTracksInfiniteQuery } = tracksApi
```

- `features/tracks/api/tracksApi.types.ts`

```ts filename="features/tracks/api/tracksApi.types.ts"
import type { CurrentUserReaction } from "@/common/enums"
import type { Images, User } from "@/common/types"

export type FetchTracksResponse = {
  data: TrackData[]
  included: TracksIncluded[]
  meta: TracksMeta
}

export type TrackData = {
  id: string
  type: "tracks"
  attributes: TrackAttributes
  relationships: TrackRelationships
}

export type TracksIncluded = {
  id: string
  type: "artists"
  attributes: {
    name: string
  }
}

export type TracksMeta = {
  nextCursor: string | null
  page: number
  pageSize: number
  totalCount: number | null
  pagesCount: number | null
}

export type TrackAttributes = {
  title: string
  addedAt: string
  attachments: TrackAttachment[]
  images: Images
  currentUserReaction: CurrentUserReaction
  user: User
  isPublished: boolean
  publishedAt: string
}

export type TrackRelationships = {
  artists: {
    data: {
      id: string
      type: string
    }
  }
}

export type TrackAttachment = {
  id: string
  addedAt: string
  updatedAt: string
  version: number
  url: string
  contentType: string
  originalName: string
  fileSize: number
}

// Arguments
export type FetchTracksArgs = {
  pageNumber?: number
  pageSize?: number
  search?: string
  sortBy?: "publishedAt" | "likesCount"
  sortDirection?: "asc" | "desc"
  tagsIds?: string[]
  artistsIds?: string[]
  userId?: string
  includeDrafts?: boolean
  paginationType?: "offset" | "cursor"
  cursor?: string
}
```

### ui

–í—ã–∑–æ–≤–µ–º —Ö—É–∫ `useFetchTracksInfiniteQuery` –∏ –ø–æ—Å–º–æ—Ç—Ä–∏ –Ω–∞ –ø–æ–ª—É—á–µ–Ω–Ω—ã–π —Ä–µ–∑—É–ª—å—Ç–∞—Ç

```tsx filename="TracksPage.tsx"
export const TracksPage = () => {
  const { data } = useFetchTracksInfiniteQuery()

  console.log(data)

  return (
    <div>
      <h1>Tracks page</h1>
    </div>
  )
}
```

–û–±—Ä–∞—Ç–∏—Ç–µ –≤–Ω–∏–º–∞–Ω–∏–µ, —á—Ç–æ —Ö—É–∫ –≤–µ—Ä–Ω—É–ª –Ω–∞–º —Å—Ç—Ä—É–∫—Ç—É—Ä—É `{pages: DataType[], pageParams: PageParam[]},`
–∫–æ—Ç–æ—Ä–∞—è —Å–æ–¥–µ—Ä–∂–∏—Ç –≤—Å–µ –ø–æ–ª—É—á–µ–Ω–Ω—ã–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã —Å—Ç—Ä–∞–Ω–∏—Ü –∏ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—â–∏–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã —Å—Ç—Ä–∞–Ω–∏—Ü, –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–Ω—ã–µ –¥–ª—è –∏—Ö –∑–∞–≥—Ä—É–∑–∫–∏.

–≠—Ç–∞ —Å—Ç—Ä—É–∫—Ç—É—Ä–∞ –æ–±–µ—Å–ø–µ—á–∏–≤–∞–µ—Ç –≥–∏–±–∫–æ—Å—Ç—å –≤ –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏–∏ –¥–∞–Ω–Ω—ã—Ö –≤ –≤–∞—à–µ–º –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–µ (–ø–æ–∫–∞–∑—ã–≤–∞—Ç—å –æ—Ç–¥–µ–ª—å–Ω—ã–µ —Å—Ç—Ä–∞–Ω–∏—Ü—ã –∏–ª–∏
–æ–±—ä–µ–¥–∏–Ω—è—Ç—å –≤ –µ–¥–∏–Ω—ã–π —Å–ø–∏—Å–æ–∫), –ø–æ–∑–≤–æ–ª—è–µ—Ç –æ–≥—Ä–∞–Ω–∏—á–∏–≤–∞—Ç—å –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Å—Ç—Ä–∞–Ω–∏—Ü, —Ö—Ä–∞–Ω—è—â–∏—Ö—Å—è –≤ –∫–µ—à–µ, –∞ —Ç–∞–∫–∂–µ –¥–∞—ë—Ç –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å
–¥–∏–Ω–∞–º–∏—á–µ—Å–∫–∏ –æ–ø—Ä–µ–¥–µ–ª—è—Ç—å —Å–ª–µ–¥—É—é—â—É—é –∏–ª–∏ –ø—Ä–µ–¥—ã–¥—É—â—É—é —Å—Ç—Ä–∞–Ω–∏—Ü—É –¥–ª—è –∑–∞–≥—Ä—É–∑–∫–∏ ‚Äî –Ω–∞ –æ—Å–Ω–æ–≤–µ —Å–∞–º–∏—Ö –¥–∞–Ω–Ω—ã—Ö –∏–ª–∏ –∏—Ö –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤.

![infinite query](https://production-it-incubator.s3.eu-central-1.amazonaws.com/file-manager/Image/c6dd0f71-4977-48a6-adc0-035e123683f5_infinite-query.png)

–û—Ç—Ä–∏—Å—É–µ–º –¥–∞–Ω–Ω—ã–µ

<Callout>
  –ß—Ç–æ–±—ã —É–º–µ–Ω—å—à–∏—Ç—å –≤–ª–æ–∂–µ–Ω–Ω–æ—Å—Ç—å –≤–æ—Å–ø–æ–ª—å–∑—É–µ–º—Å—è `flat` –∏–ª–∏ `flatMap`
  - [flat](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/flat)
  - [flatMap](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/flatMap)

</Callout>

- `TracksPage.tsx`

```tsx filename="TracksPage.tsx"
import { useFetchTracksInfiniteQuery } from "../../api/tracksApi.ts"
import s from "./TracksPage.module.css"

export const TracksPage = () => {
  const { data } = useFetchTracksInfiniteQuery({ paginationType: "cursor", pageSize: 5 })

  const pages = data?.pages.map((page) => page.data).flat() || []
  // const pages = data?.pages.flatMap((page) => page.data) || []

  return (
    <div>
      <h1>Tracks page</h1>
      <div className={s.list}>
        {pages.map((track) => {
          const { title, user, attachments } = track.attributes

          return (
            <div key={track.id} className={s.item}>
              <div>
                <p>Title: {title}</p>
                <p>Name: {user.name}</p>
              </div>
              {attachments.length ? <audio controls src={attachments[0].url} /> : "no file"}
            </div>
          )
        })}
      </div>
    </div>
  )
}
```

- `TracksPage.module.css`

```css filename="TracksPage.module.css"
.list {
  display: flex;
  flex-direction: column;
  gap: 20px;
}

.item {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 16px;
  border: 1px solid #ddd;
  border-radius: 8px;
}
```

**–†–µ–∑—É–ª—å—Ç–∞—Ç:** –æ—Ç—Ä–∏—Å–æ–≤–∞–ª–∏ –ø–µ—Ä–≤—É—é —Å—Ç—Ä–∞–Ω–∏—Ü—É üöÄ

### load more

```tsx filename="TracksPage.tsx"
export const TracksPage = () => {
  const { data, isLoading, isFetching, isFetchingNextPage, fetchNextPage, hasNextPage } = useFetchTracksInfiniteQuery()

  const pages = data?.pages.flatMap((page) => page.data) || []

  const loadMoreHandler = () => {
    if (hasNextPage && !isFetching) {
      fetchNextPage()
    }
  }

  return (
    <div>
      {/*...*/}

      {!isLoading && (
        <>
          {hasNextPage ? (
            <button onClick={loadMoreHandler} disabled={isFetching}>
              {isFetchingNextPage ? "Loading..." : "Load More"}
            </button>
          ) : (
            <p>Nothing more to load</p>
          )}
        </>
      )}
    </div>
  )
}
```

**–†–µ–∑—É–ª—å—Ç–∞—Ç:** –ø—Ä–∏ –Ω–∞–∂–∞—Ç–∏–∏ –Ω–∞ –∫–Ω–æ–ø–∫—É `load more` —Ç—Ä–µ–∫–∏ –ø–æ–¥–≥—Ä—É–∂–∞—é—Ç—Å—è –¥–æ —Ç–µ—Ö –ø–æ—Ä, –ø–æ–∫–∞ –ø–æ–ª–Ω–æ—Å—Ç—å—é –Ω–µ –ø–æ–¥–≥—Ä—É–∑—è—Ç—Å—è üöÄ

### infinity scroll

## offset paginate
