import { Callout } from "nextra/components"

# 9. Infinity queries

–†–µ–∞–ª–∏–∑—É–µ–º –±–µ—Å–∫–æ–Ω–µ—á–Ω—ã–π —Å–∫—Ä–æ–ª–ª –Ω–∞ —Å—Ç—Ä–∞–Ω–∏—Ü–µ —Å —Ç—Ä–µ–∫–∞–º–∏

<Callout type={"info"} emoji={"üîó"}>
  [Infinite Queries](https://redux-toolkit.js.org/rtk-query/usage/infinite-queries)
</Callout>

`infiniteQuery` –ø–æ–¥—Ö–æ–¥–∏—Ç –¥–ª—è:

- –ë–µ—Å–∫–æ–Ω–µ—á–Ω–æ–π –ø—Ä–æ–∫—Ä—É—Ç–∫–∏ (infinite scroll)
- –ö–Ω–æ–ø–∫–∏ "–ó–∞–≥—Ä—É–∑–∏—Ç—å –µ—â–µ"
- –õ–µ–Ω—Ç—ã –Ω–æ–≤–æ—Å—Ç–µ–π/–ø–æ—Å—Ç–æ–≤
- –ö–æ–≥–¥–∞ –Ω—É–∂–Ω–æ –ø–æ–∫–∞–∑–∞—Ç—å –≤—Å–µ –¥–∞–Ω–Ω—ã–µ –≤ –æ–¥–Ω–æ–º —Å–ø–∏—Å–∫–µ

## Cursor paginate

`–ö—É—Ä—Å–æ—Ä–Ω–∞—è –ø–∞–≥–∏–Ω–∞—Ü–∏—è` - —ç—Ç–æ —Å–ø–æ—Å–æ–± —Ä–∞–∑–±–∏–≤–∫–∏ –¥–∞–Ω–Ω—ã—Ö –Ω–∞ —Å—Ç—Ä–∞–Ω–∏—Ü—ã —Å –ø–æ–º–æ—â—å—é —É–Ω–∏–∫–∞–ª—å–Ω–æ–≥–æ —É–∫–∞–∑–∞—Ç–µ–ª—è (–∫—É—Ä—Å–æ—Ä–∞)
–≤–º–µ—Å—Ç–æ –Ω–æ–º–µ—Ä–æ–≤ —Å—Ç—Ä–∞–Ω–∏—Ü.

**–ü—Ä–∏–Ω—Ü–∏–ø:**

- –ö—É—Ä—Å–æ—Ä - —ç—Ç–æ ID –ø–æ—Å–ª–µ–¥–Ω–µ–≥–æ —ç–ª–µ–º–µ–Ω—Ç–∞ –Ω–∞ —Ç–µ–∫—É—â–µ–π —Å—Ç—Ä–∞–Ω–∏—Ü–µ
- –°–ª–µ–¥—É—é—â–∞—è —Å—Ç—Ä–∞–Ω–∏—Ü–∞ –Ω–∞—á–∏–Ω–∞–µ—Ç—Å—è –ø–æ—Å–ª–µ —ç—Ç–æ–≥–æ –∫—É—Ä—Å–æ—Ä–∞
- –ù–µ—Ç –ø—Ä–æ–ø—É—Å–∫–æ–≤ - –¥–∞–∂–µ –µ—Å–ª–∏ –¥–æ–±–∞–≤–ª—è—é—Ç—Å—è –Ω–æ–≤—ã–µ –∑–∞–ø–∏—Å–∏

**–ü—Ä–µ–∏–º—É—â–µ—Å—Ç–≤–∞:**

- –°—Ç–∞–±–∏–ª—å–Ω–æ—Å—Ç—å - –Ω–µ—Ç –¥—É–±–ª–∏—Ä–æ–≤–∞–Ω–∏—è –ø—Ä–∏ –¥–æ–±–∞–≤–ª–µ–Ω–∏–∏ –Ω–æ–≤—ã—Ö –∑–∞–ø–∏—Å–µ–π
- –ü—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å - –±—ã—Å—Ç—Ä–µ–µ –¥–ª—è –±–æ–ª—å—à–∏—Ö –æ–±—ä–µ–º–æ–≤ –¥–∞–Ω–Ω—ã—Ö
- –†–µ–∞–ª—å–Ω–æ–µ –≤—Ä–µ–º—è - —Ä–∞–±–æ—Ç–∞–µ—Ç —Å –ø–æ—Å—Ç–æ—è–Ω–Ω–æ –æ–±–Ω–æ–≤–ª—è—é—â–∏–º–∏—Å—è –¥–∞–Ω–Ω—ã–º–∏

**–ù–µ–¥–æ—Å—Ç–∞—Ç–∫–∏:**

- –ù–µ–ª—å–∑—è –ø—Ä—ã–≥–∞—Ç—å –Ω–∞ –ø—Ä–æ–∏–∑–≤–æ–ª—å–Ω—É—é —Å—Ç—Ä–∞–Ω–∏—Ü—É
- –¢–æ–ª—å–∫–æ –≤–ø–µ—Ä–µ–¥ - –æ–±—ã—á–Ω–æ –Ω–µ—Ç –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–∏ –≤–µ—Ä–Ω—É—Ç—å—Å—è –Ω–∞–∑–∞–¥

**–ò–¥–µ–∞–ª—å–Ω–æ –¥–ª—è**: –ª–µ–Ω—Ç –Ω–æ–≤–æ—Å—Ç–µ–π, —á–∞—Ç–æ–≤, –±–µ—Å–∫–æ–Ω–µ—á–Ω–æ–π –ø—Ä–æ–∫—Ä—É—Ç–∫–∏.

### api

- `features/tracks/api/tracksApi.ts`

```ts filename="features/tracks/api/tracksApi.ts"
export const tracksApi = baseApi.injectEndpoints({
  endpoints: (build) => ({
    fetchTracks: build.infiniteQuery<FetchTracksResponse, void, string | undefined>({
      infiniteQueryOptions: {
        initialPageParam: undefined,
        getNextPageParam: (lastPage) => {
          return lastPage.meta.nextCursor || undefined
        },
      },
      query: ({ pageParam }) => {
        return {
          url: "playlists/tracks",
          params: { cursor: pageParam, pageSize: 5, paginationType: "cursor" },
        }
      },
    }),
  }),
})
export const { useFetchTracksInfiniteQuery } = tracksApi
```

- `features/tracks/api/tracksApi.types.ts`

```ts filename="features/tracks/api/tracksApi.types.ts"
import type { CurrentUserReaction } from "@/common/enums"
import type { Images, User } from "@/common/types"

export type FetchTracksResponse = {
  data: TrackData[]
  included: TracksIncluded[]
  meta: TracksMeta
}

export type TrackData = {
  id: string
  type: "tracks"
  attributes: TrackAttributes
  relationships: TrackRelationships
}

export type TracksIncluded = {
  id: string
  type: "artists"
  attributes: {
    name: string
  }
}

export type TracksMeta = {
  nextCursor: string | null
  page: number
  pageSize: number
  totalCount: number | null
  pagesCount: number | null
}

export type TrackAttributes = {
  title: string
  addedAt: string
  attachments: TrackAttachment[]
  images: Images
  currentUserReaction: CurrentUserReaction
  user: User
  isPublished: boolean
  publishedAt: string
}

export type TrackRelationships = {
  artists: {
    data: {
      id: string
      type: string
    }
  }
}

export type TrackAttachment = {
  id: string
  addedAt: string
  updatedAt: string
  version: number
  url: string
  contentType: string
  originalName: string
  fileSize: number
}

// Arguments
export type FetchTracksArgs = {
  pageNumber?: number
  pageSize?: number
  search?: string
  sortBy?: "publishedAt" | "likesCount"
  sortDirection?: "asc" | "desc"
  tagsIds?: string[]
  artistsIds?: string[]
  userId?: string
  includeDrafts?: boolean
  paginationType?: "offset" | "cursor"
  cursor?: string
}
```

### ui

–í—ã–∑–æ–≤–µ–º —Ö—É–∫ `useFetchTracksInfiniteQuery` –∏ –ø–æ—Å–º–æ—Ç—Ä–∏ –Ω–∞ –ø–æ–ª—É—á–µ–Ω–Ω—ã–π —Ä–µ–∑—É–ª—å—Ç–∞—Ç

```tsx filename="TracksPage.tsx"
export const TracksPage = () => {
  const { data } = useFetchTracksInfiniteQuery()

  console.log(data)

  return (
    <div>
      <h1>Tracks page</h1>
    </div>
  )
}
```

–û–±—Ä–∞—Ç–∏—Ç–µ –≤–Ω–∏–º–∞–Ω–∏–µ, —á—Ç–æ —Ö—É–∫ –≤–µ—Ä–Ω—É–ª –Ω–∞–º —Å—Ç—Ä—É–∫—Ç—É—Ä—É `{pages: DataType[], pageParams: PageParam[]},`
–∫–æ—Ç–æ—Ä–∞—è —Å–æ–¥–µ—Ä–∂–∏—Ç –≤—Å–µ –ø–æ–ª—É—á–µ–Ω–Ω—ã–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã —Å—Ç—Ä–∞–Ω–∏—Ü –∏ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—â–∏–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã —Å—Ç—Ä–∞–Ω–∏—Ü, –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–Ω—ã–µ –¥–ª—è –∏—Ö –∑–∞–≥—Ä—É–∑–∫–∏.

–≠—Ç–∞ —Å—Ç—Ä—É–∫—Ç—É—Ä–∞ –æ–±–µ—Å–ø–µ—á–∏–≤–∞–µ—Ç –≥–∏–±–∫–æ—Å—Ç—å –≤ –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏–∏ –¥–∞–Ω–Ω—ã—Ö –≤ –≤–∞—à–µ–º –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–µ (–ø–æ–∫–∞–∑—ã–≤–∞—Ç—å –æ—Ç–¥–µ–ª—å–Ω—ã–µ —Å—Ç—Ä–∞–Ω–∏—Ü—ã –∏–ª–∏
–æ–±—ä–µ–¥–∏–Ω—è—Ç—å –≤ –µ–¥–∏–Ω—ã–π —Å–ø–∏—Å–æ–∫), –ø–æ–∑–≤–æ–ª—è–µ—Ç –æ–≥—Ä–∞–Ω–∏—á–∏–≤–∞—Ç—å –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Å—Ç—Ä–∞–Ω–∏—Ü, —Ö—Ä–∞–Ω—è—â–∏—Ö—Å—è –≤ –∫–µ—à–µ, –∞ —Ç–∞–∫–∂–µ –¥–∞—ë—Ç –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å
–¥–∏–Ω–∞–º–∏—á–µ—Å–∫–∏ –æ–ø—Ä–µ–¥–µ–ª—è—Ç—å —Å–ª–µ–¥—É—é—â—É—é –∏–ª–∏ –ø—Ä–µ–¥—ã–¥—É—â—É—é —Å—Ç—Ä–∞–Ω–∏—Ü—É –¥–ª—è –∑–∞–≥—Ä—É–∑–∫–∏ ‚Äî –Ω–∞ –æ—Å–Ω–æ–≤–µ —Å–∞–º–∏—Ö –¥–∞–Ω–Ω—ã—Ö –∏–ª–∏ –∏—Ö –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤.

![infinite query](https://production-it-incubator.s3.eu-central-1.amazonaws.com/file-manager/Image/c6dd0f71-4977-48a6-adc0-035e123683f5_infinite-query.png)

–û—Ç—Ä–∏—Å—É–µ–º –¥–∞–Ω–Ω—ã–µ

<Callout>
  –ß—Ç–æ–±—ã —É–º–µ–Ω—å—à–∏—Ç—å –≤–ª–æ–∂–µ–Ω–Ω–æ—Å—Ç—å –≤–æ—Å–ø–æ–ª—å–∑—É–µ–º—Å—è `flat` –∏–ª–∏ `flatMap`
  - [flat](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/flat)
  - [flatMap](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/flatMap)

</Callout>

- `TracksPage.tsx`

```tsx filename="TracksPage.tsx"
import { useFetchTracksInfiniteQuery } from "../../api/tracksApi.ts"
import s from "./TracksPage.module.css"

export const TracksPage = () => {
  const { data } = useFetchTracksInfiniteQuery({ paginationType: "cursor", pageSize: 5 })

  const pages = data?.pages.map((page) => page.data).flat() || []
  // const pages = data?.pages.flatMap((page) => page.data) || []

  return (
    <div>
      <h1>Tracks page</h1>
      <div className={s.list}>
        {pages.map((track) => {
          const { title, user, attachments } = track.attributes

          return (
            <div key={track.id} className={s.item}>
              <div>
                <p>Title: {title}</p>
                <p>Name: {user.name}</p>
              </div>
              {attachments.length ? <audio controls src={attachments[0].url} /> : "no file"}
            </div>
          )
        })}
      </div>
    </div>
  )
}
```

- `TracksPage.module.css`

```css filename="TracksPage.module.css"
.list {
  display: flex;
  flex-direction: column;
  gap: 20px;
}

.item {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 16px;
  border: 1px solid #ddd;
  border-radius: 8px;
}
```

**–†–µ–∑—É–ª—å—Ç–∞—Ç:** –æ—Ç—Ä–∏—Å–æ–≤–∞–ª–∏ –ø–µ—Ä–≤—É—é —Å—Ç—Ä–∞–Ω–∏—Ü—É üöÄ

### Load more

```tsx filename="TracksPage.tsx"
export const TracksPage = () => {
  const { data, isLoading, isFetching, isFetchingNextPage, fetchNextPage, hasNextPage } = useFetchTracksInfiniteQuery()

  const pages = data?.pages.flatMap((page) => page.data) || []

  const loadMoreHandler = () => {
    if (hasNextPage && !isFetching) {
      fetchNextPage()
    }
  }

  return (
    <div>
      {/*...*/}

      {!isLoading && (
        <>
          {hasNextPage ? (
            <button onClick={loadMoreHandler} disabled={isFetching}>
              {isFetchingNextPage ? "Loading..." : "Load More"}
            </button>
          ) : (
            <p>Nothing more to load</p>
          )}
        </>
      )}
    </div>
  )
}
```

**–†–µ–∑—É–ª—å—Ç–∞—Ç:** –ø—Ä–∏ –Ω–∞–∂–∞—Ç–∏–∏ –Ω–∞ –∫–Ω–æ–ø–∫—É `load more` —Ç—Ä–µ–∫–∏ –ø–æ–¥–≥—Ä—É–∂–∞—é—Ç—Å—è –¥–æ —Ç–µ—Ö –ø–æ—Ä, –ø–æ–∫–∞ –ø–æ–ª–Ω–æ—Å—Ç—å—é –Ω–µ –ø–æ–¥–≥—Ä—É–∑—è—Ç—Å—è üöÄ

### Infinity scroll

–ú—ã —Ö–æ—Ç–∏–º –ø—Ä–∏ –ø—Ä–æ–∫—Ä—É—Ç–∫–µ –≤–Ω–∏–∑ —á—Ç–æ–±—ã —Ç—Ä–µ–∫–∏ –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –¥–æ–±–∞–≤–ª—è–ª–∏—Å—å. –ß—Ç–æ–±—ã —Ä–µ–∞–ª–∏–∑–æ–≤–∞—Ç—å –¥–∞–Ω–Ω—É—é –∑–∞–¥–∞—á—É –Ω–∞–º –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ
–æ—Ç—Å–ª–µ–∂–∏–≤–∞—Ç—å –º–æ–º–µ–Ω—Ç –∫–æ–≥–¥–∞ –º—ã –¥–æ–º–æ—Ç–∞–ª–∏ –¥–æ –∫–æ–Ω—Ü–∞ —Å—Ç—Ä–∞–Ω–∏—Ü—ã –∏ –¥–µ–ª–∞—Ç—å —Å—Ä–∞–∑—É –∂–µ –∑–∞–ø—Ä–æ—Å.

–î–ª—è —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–∏ –¥–∞–Ω–Ω–æ–π –∑–∞–¥–∞—á–∏ –º–æ–∂–Ω–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –±–∏–±–ª–∏–æ—Ç–µ–∫—É `react-intersection-observer`

<Callout type={'info'} emoji={'üîó'}>
  - [react-intersection-observer](https://www.npmjs.com/package/react-intersection-observer)

</Callout>

–ù–æ –º–æ–∂–Ω–æ –æ–±–æ–π—Ç–∏—Å—å –±–µ–∑ –±–∏–±–ª–∏–æ—Ç–µ–∫–∏ –∏ –Ω–∞–ø–∏—Å–∞—Ç—å —Å–∞–º–æ—Å—Ç–æ—è—Ç–µ–ª—å–Ω–æ.

```tsx filename="TracksPage.tsx"
export const TracksPage = () => {
  const { data, isFetching, isFetchingNextPage, fetchNextPage, hasNextPage } = useFetchTracksInfiniteQuery()

  // Creates a reference to the DOM element that will be the "trigger" for auto-loading
  const observerRef = useRef<HTMLDivElement>(null)

  const pages = data?.pages.flatMap((page) => page.data) || []

  const loadMoreHandler = useCallback(() => {
    if (hasNextPage && !isFetching) {
      fetchNextPage()
    }
  }, [hasNextPage, isFetching, fetchNextPage])

  useEffect(() => {
    // IntersectionObserver monitors elements and reports how visible they are in the viewport
    // https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API
    const observer = new IntersectionObserver(
      (entries) => {
        // entries - observed element
        if (entries.length > 0 && entries[0].isIntersecting) {
          loadMoreHandler()
        }
      },
      {
        root: null, // Tracking relative to the browser window (viewport). null = entire screen
        rootMargin: "100px", // Start loading 100px before the element appears
        threshold: 0.1, // Trigger when 10% of the element becomes visible
      },
    )

    const currentObserverRef = observerRef.current
    if (currentObserverRef) {
      // starts observing the element
      observer.observe(currentObserverRef)
    }

    // Cleanup function - stops observing when component unmounts
    return () => {
      if (currentObserverRef) {
        observer.unobserve(currentObserverRef)
      }
    }
  }, [loadMoreHandler])

  return (
    <div>
      <h1>Tracks page</h1>
      <div className={s.list}>
        {pages.map((track) => {
          const { title, user, attachments } = track.attributes

          return (
            <div key={track.id} className={s.item}>
              <div>
                <p>Title: {title}</p>
                <p>Name: {user.name}</p>
              </div>
              {attachments.length ? <audio controls src={attachments[0].url} /> : "no file"}
            </div>
          )
        })}
      </div>

      {hasNextPage && (
        // This element is observed by IntersectionObserver
        <div ref={observerRef}>
          {/*<div style={{ height: '20px' }} />` creates an "invisible zone" of 20px at the end of the list,*/}
          {/*when reached, new tracks are automatically loaded. Without dimensions,*/}
          {/*IntersectionObserver wouldn't work correctly.*/}
          {isFetchingNextPage ? <div>Loading more tracks...</div> : <div style={{ height: "20px" }} />}
        </div>
      )}

      {!hasNextPage && pages.length > 0 && <p>Nothing more to load</p>}
    </div>
  )
}
```

**–†–µ–∑—É–ª—å—Ç–∞—Ç:** infinity scroll —Ä–µ–∞–ª–∏–∑–æ–≤–∞–Ω üöÄ

### –î–µ–∫–æ–º–ø–æ–∑–∏—Ü–∏—è

- `common/hooks/useInfiniteScroll.ts`

```ts filename="useInfiniteScroll.ts"
import { useCallback, useEffect, useRef } from "react"

type Props = {
  hasNextPage: boolean
  isFetching: boolean
  fetchNextPage: () => void
  rootMargin?: string
  threshold?: number
}

export const useInfiniteScroll = ({
  hasNextPage,
  isFetching,
  fetchNextPage,
  rootMargin = "100px",
  threshold = 0.1,
}: Props) => {
  const observerRef = useRef<HTMLDivElement>(null)

  const loadMoreHandler = useCallback(() => {
    if (hasNextPage && !isFetching) {
      fetchNextPage()
    }
  }, [hasNextPage, isFetching, fetchNextPage])

  useEffect(() => {
    // IntersectionObserver monitors elements and reports how visible they are in the viewport
    // https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API
    const observer = new IntersectionObserver(
      (entries) => {
        // entries - observed element
        if (entries.length > 0 && entries[0].isIntersecting) {
          loadMoreHandler()
        }
      },
      {
        root: null, // Tracking relative to the browser window (viewport). null = entire screen
        rootMargin, // Start loading before the element appears
        threshold, // Trigger when % of the element becomes visible
      },
    )

    const currentObserverRef = observerRef.current
    if (currentObserverRef) {
      // starts observing the element
      observer.observe(currentObserverRef)
    }

    // Cleanup function - stops observing when component unmounts
    return () => {
      if (currentObserverRef) {
        observer.unobserve(currentObserverRef)
      }
    }
  }, [loadMoreHandler, rootMargin, threshold])

  return { observerRef }
}
```

- `TracksList.tsx`

<Callout type={"warning"}>–ü–µ—Ä–µ–Ω–µ—Å–∏—Ç–µ —Å—Ç–∏–ª–∏ –∏–∑ `TracksPage.module.css` –≤ `TracksList.module.css`</Callout>

```tsx filename="TracksList.tsx"
import type { TrackData } from "../../../api/tracksApi.types.ts"
import s from "./TracksList.module.css"

type Props = {
  tracks: TrackData[]
}

export const TracksList = ({ tracks }: Props) => {
  return (
    <div className={s.list}>
      {tracks.map((track) => {
        const { title, user, attachments } = track.attributes

        return (
          <div key={track.id} className={s.item}>
            <div>
              <p>Title: {title}</p>
              <p>Name: {user.name}</p>
            </div>
            {attachments.length ? <audio controls src={attachments[0].url} /> : "no file"}
          </div>
        )
      })}
    </div>
  )
}
```

- `LoadingTrigger.tsx`

```tsx filename="LoadingTrigger.tsx"
import type { RefObject } from "react"

type Props = {
  observerRef: RefObject<HTMLDivElement | null>
  isFetchingNextPage: boolean
}

export const LoadingTrigger = ({ observerRef, isFetchingNextPage }: Props) => {
  // This element is observed by IntersectionObserver
  return (
    <div ref={observerRef}>
      {/*<div style={{ height: '20px' }} />` creates an "invisible zone" of 20px at the end of the list,*/}
      {/*when reached, new tracks are automatically loaded. Without dimensions,*/}
      {/*IntersectionObserver wouldn't work correctly.*/}
      {isFetchingNextPage ? <div>Loading more tracks...</div> : <div style={{ height: "20px" }} />}
    </div>
  )
}
```

- `TracksPage.tsx`

```tsx filename="TracksPage.tsx"
export const TracksPage = () => {
  const { data, isFetching, isFetchingNextPage, fetchNextPage, hasNextPage } = useFetchTracksInfiniteQuery()

  const { observerRef } = useInfiniteScroll({ hasNextPage, isFetching, fetchNextPage })

  const pages = data?.pages.flatMap((page) => page.data) || []

  return (
    <div>
      <h1>Tracks page</h1>
      <TracksList tracks={pages} />
      {hasNextPage && <LoadingTrigger isFetchingNextPage={isFetchingNextPage} observerRef={observerRef} />}
      {!hasNextPage && pages.length > 0 && <p>Nothing more to load</p>}
    </div>
  )
}
```

**–†–µ–∑—É–ª—å—Ç–∞—Ç:** –¥–µ–∫–æ–º–ø–æ–∑–∏—Ü–∏—è –∑–∞–≤–µ—Ä—à–µ–Ω–∞. –ö–æ–¥ —Ä–∞–±–æ—Ç–∞–µ—Ç üöÄ

## Offset paginate

`Offset` –ø–∞–≥–∏–Ω–∞—Ü–∏—è ‚Äî —ç—Ç–æ —Å–ø–æ—Å–æ–± —Ä–∞–∑–±–∏–≤–∫–∏ –¥–∞–Ω–Ω—ã—Ö –Ω–∞ —Å—Ç—Ä–∞–Ω–∏—Ü—ã, –ø—Ä–∏ –∫–æ—Ç–æ—Ä–æ–º —É–∫–∞–∑—ã–≤–∞–µ—Ç—Å—è, —Å –∫–∞–∫–æ–≥–æ —ç–ª–µ–º–µ–Ω—Ç–∞ –Ω–∞—á–∏–Ω–∞—Ç—å –≤—ã–±–æ—Ä–∫—É
(`offset`) –∏ —Å–∫–æ–ª—å–∫–æ —ç–ª–µ–º–µ–Ω—Ç–æ–≤ –≤–∑—è—Ç—å (`limit`).

```tsx filename="tracksApi.ts" {3, 7, 13}
export const tracksApi = baseApi.injectEndpoints({
  endpoints: (build) => ({
    fetchTracks: build.infiniteQuery<FetchTracksResponse, void, number>({
      infiniteQueryOptions: {
        initialPageParam: 1,
        getNextPageParam: (lastPage, _allPages, lastPageParam) => {
          return lastPageParam < (lastPage.meta as { pagesCount: number }).pagesCount ? lastPageParam + 1 : undefined
        },
      },
      query: ({ pageParam }) => {
        return {
          url: "playlists/tracks",
          params: { pageNumber: pageParam, pageSize: 10, paginationType: "offset" },
        }
      },
    }),
  }),
})

export const { useFetchTracksInfiniteQuery } = tracksApi
```
